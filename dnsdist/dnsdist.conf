setVerbose(true)

-- listen
addLocal("0.0.0.0:1053")

-- upstreams
newServer({ address = "1.1.1.1:53",     pool = "primary",  name = "cloudflare" })
newServer({ address = "10.157.8.18:53", pool = "fallback", name = "internal-10" })

-- only this suffix (note trailing dot)
local smn = newSuffixMatchNode()
smn:add("github.internal.")

-- Tag and mark restartable BEFORE routing (first-match wins)
addAction(SuffixMatchNodeRule(smn), LuaAction(function(dq)
  dq:setTag("nx-retry", "0")
  dq:setRestartable()          -- <-- keep a copy so we can restart later
  dq.pool = "primary"          -- not strictly needed, but explicit
  return DNSAction.None
end))

-- Route *.github.internal. to primary first
addAction(SuffixMatchNodeRule(smn), PoolAction("primary"))

-- Default: everything else to primary
addAction(AllRule(), PoolAction("primary"))

-- Optional log of responses for that suffix
addResponseAction(SuffixMatchNodeRule(smn), LuaResponseAction(function(dr)
  print(string.format("[dnsdist] %s rcode=%d from %s",
    dr.qname:toString(), dr.rcode, "1.1.1.1"))
  return DNSResponseAction.None
end))

-- If NXDOMAIN for *.github.internal. and not retried yet -> restart via fallback
addResponseAction(
  AndRule({
    SuffixMatchNodeRule(smn),
    RCodeRule(DNSRCode.NXDOMAIN),
    TagRule("nx-retry", "0")
  }),
  LuaResponseAction(function(dr)
    print(string.format("[dnsdist] NXDOMAIN from %s for %s -> restart via fallback",
      "1.1.1.1", dr.qname:toString()))
    dr:setTag("nx-retry", "1")
    dr.pool = "fallback"   -- send the restarted query to the fallback pool
    dr:restart()           -- discard current resp and re-issue the query
    return DNSResponseAction.None
  end)
)
